00101000 10110001 -> 40 b1
01000101 10001010 -> 45 8a

10101010 10101011 -> aa ab
11000011 00011100 -> c3 1c
00

거꾸로 저장됨 -> 리틀엔디안이니깐?

아니 근데, 66 비트인데

왜 이렇게 계산함
16 32 64
48 + 64 = 112

00101000
10110001
01000101
10001010

10

10101010
10101111
00001100
01110000


왜 이따구로 되지?

66bits를 넣었는데


01110000
00001100
10101111
10101010

10001010
01000101
10110001
00101000





70 0c af aa 8a 45 b1 28




00

앞에 64비트를 보자.

8+32 = 112



아 이제 알겠네.
어떻게 하냐면

임의의 값 배열로 넣고
어떻게 저장됐는지 메모리 덤프 떠보고
판단하는거지.


원본 :
001010001011000101000101100010101010101010101011110000110001110000
수정본 :
0010100010110001010001011000101010101010101011110000110001110000

0111000000001100101011111010101010001010010001011011000100101000



---

00000001
00000011
00000111
00001111
00011111
00111111
01111111
11111111
01111111
00111111
00011111
00001111
00000111
00000011
00000001

---

아니 그러면 죄다 거꾸로 저장한다는 거임?

내가 생각한건

배열은 그대로 저장하고

데이터 각각이 1 바이트 넘어가면 그 안에서만 거꾸로 된다는걸로 알고 있었는데?

---
